<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Picos_structured (picos.Picos_structured)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">picos</a> &#x00BB; Picos_structured</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Picos_structured</span></code></h1><p>Basic structured concurrency primitives for <a href="../Picos/index.html"><code>Picos</code></a>.</p><p>This library essentially provides one user level interface for structuring fibers with any Picos compatible scheduler. This library is both meant to serve as an example of what can be done and to also provide practical means for programming with fibers. Hopefully there will be many more libraries implemented in Picos like this providing different approaches, patterns, and idioms for structuring concurrent programs.</p></header><nav class="odoc-toc"><ul><li><a href="#modules">Modules</a></li><li><a href="#examples">Examples</a><ul><li><a href="#a-simple-echo-server-and-clients">A simple echo server and clients</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="modules"><a href="#modules" class="anchor"></a>Modules</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Finally"><a href="#module-Finally" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Finally/index.html">Finally</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Syntax for avoiding resource leaks.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Control"><a href="#module-Control" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Control/index.html">Control</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Basic control operations and exceptions for structured concurrency.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Bundle"><a href="#module-Bundle" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Bundle/index.html">Bundle</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A dynamic bundle of fibers guaranteed to be joined at the end.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Run"><a href="#module-Run" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Run/index.html">Run</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Operations for running fibers in specific patterns.</p></div></div><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p>First we open some modules for convenience:</p><pre class="language-ocaml"><code>open Picos_structured.Finally
open Picos_structured
open Picos_stdio
open Picos_sync</code></pre><h3 id="a-simple-echo-server-and-clients"><a href="#a-simple-echo-server-and-clients" class="anchor"></a>A simple echo server and clients</h3><p>Here is an example of a simple TCP echo server and two clients:</p><pre class="language-ocaml"><code># Picos_fifos.run ~forbid:false @@ fun () -&gt;
  let max_size = 100 in

  (* We let the system pick the port *)
  let loopback_0 = Unix.(ADDR_INET (inet_addr_loopback, 0)) in
  let server_addr = ref loopback_0 in
  let mutex = Mutex.create () in
  let condition = Condition.create () in

  let server () =
    let@ socket =
      finally Unix.close @@ fun () -&gt;
      Unix.socket ~cloexec:true PF_INET SOCK_STREAM 0
    in
    Unix.set_nonblock socket;
    Unix.bind socket loopback_0;
    Mutex.protect mutex begin fun () -&gt;
      server_addr := Unix.getsockname socket
    end;
    Condition.signal condition;
    Unix.listen socket 8;

    Bundle.join_after begin fun bundle -&gt;
      while true do
        let^ client =
          finally Unix.close @@ fun () -&gt;
          Unix.accept ~cloexec:true socket |&gt; fst
        in

        (* Fork a new fiber for each client *)
        Bundle.fork bundle begin fun () -&gt;
          let@ client = move client in
          Unix.set_nonblock client;

          let bytes = Bytes.create max_size in
          let n = Unix.read client bytes 0 (Bytes.length bytes) in

          Unix.write client bytes 0 n |&gt; ignore
        end
      done
    end
  in

  let client () =
    let@ socket =
      finally Unix.close @@ fun () -&gt;
      Unix.socket ~cloexec:true PF_INET SOCK_STREAM 0
    in
    Unix.set_nonblock socket;
    Unix.connect socket !server_addr;

    let msg = &quot;Hello!&quot; in
    Unix.write_substring socket msg 0 (String.length msg) |&gt; ignore;

    let bytes = Bytes.create max_size in
    let n = Unix.read socket bytes 0 (Bytes.length bytes) in

    Printf.printf &quot;Received: %s\n%!&quot; (Bytes.sub_string bytes 0 n)
  in

  Bundle.join_after begin fun bundle -&gt;
    (* Start server *)
    Bundle.fork bundle server;

    (* Wait until server address has been determined *)
    Mutex.protect mutex begin fun () -&gt;
      while !server_addr == loopback_0 do
        Condition.wait condition mutex
      done
    end;

    (* Start some clients and wait until they are done *)
    Bundle.join_after begin fun bundle -&gt;
      for _=1 to 5 do
        Bundle.fork bundle client
      done
    end;

    (* Stop server *)
    Bundle.terminate bundle
  end
Received: Hello!
Received: Hello!
Received: Hello!
Received: Hello!
Received: Hello!
- : unit = ()</code></pre><p>As an exercise, you might want to refactor the server to avoid <a href="Finally/index.html#val-move" title="Finally.move">moving</a> the file descriptors and use a <a href="Finally/index.html#val-let@" title="Finally.let@">recursive</a> accept loop instead.</p></div></body></html>
