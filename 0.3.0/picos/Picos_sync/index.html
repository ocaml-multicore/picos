<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Picos_sync (picos.Picos_sync)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">picos</a> &#x00BB; Picos_sync</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Picos_sync</span></code></h1><p>Basic communication and synchronization primitives for <a href="../Picos/index.html"><code>Picos</code></a>.</p><p>The optional <code>padded</code> argument taken by several constructor functions, e.g. <a href="Mutex/index.html#val-create"><code>Mutex.create</code></a> and <a href="Condition/index.html#val-create"><code>Condition.create</code></a>, defaults to <code>false</code>. When explicitly specified as <code>~padded:true</code> the object is allocated in a way to avoid <a href="https://en.wikipedia.org/wiki/False_sharing">false sharing</a>. For relatively long lived objects this can improve performance and make performance more stable at the cost of using more memory. It is not recommended to use <code>~padded:true</code> for short lived objects.</p></header><nav class="odoc-toc"><ul><li><a href="#modules">Modules</a></li><li><a href="#examples">Examples</a><ul><li><a href="#a-simple-bounded-queue">A simple bounded queue</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="modules"><a href="#modules" class="anchor"></a>Modules</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Mutex"><a href="#module-Mutex" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Mutex/index.html">Mutex</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A mutex implementation for <a href="../Picos/index.html"><code>Picos</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Condition"><a href="#module-Condition" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Condition/index.html">Condition</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A condition implementation for <a href="../Picos/index.html"><code>Picos</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Lazy"><a href="#module-Lazy" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Lazy/index.html">Lazy</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A lazy implementation for <a href="../Picos/index.html"><code>Picos</code></a>.</p></div></div><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p>First we open some modules for convenience:</p><pre class="language-ocaml"><code>open Picos_structured
open Picos_sync</code></pre><h3 id="a-simple-bounded-queue"><a href="#a-simple-bounded-queue" class="anchor"></a>A simple bounded queue</h3><p>Here is an example of a simple bounded (blocking) queue using a mutex and condition variables:</p><pre class="language-ocaml"><code>module Bounded_queue : sig
  type 'a t
  val create : ?capacity:int -&gt; unit -&gt; 'a t
  val push : 'a t -&gt; 'a -&gt; unit
  val pop : 'a t -&gt; 'a
end = struct
  type 'a t = {
    mutex : Mutex.t;
    queue : 'a Queue.t;
    capacity : int;
    not_empty : Condition.t;
    not_full : Condition.t;
  }

  let create ?(capacity = Int.max_int) () =
    if capacity &lt; 0 then
      invalid_arg &quot;capacity cannot be negative&quot;
    else {
      mutex = Mutex.create ();
      queue = Queue.create ();
      capacity;
      not_empty = Condition.create ();
      not_full = Condition.create ();
    }

  let push t x =
    let was_empty =
      Mutex.protect t.mutex @@ fun () -&gt;
      while t.capacity &lt;= Queue.length t.queue do
        Condition.wait t.not_full t.mutex
      done;
      Queue.push x t.queue;
      Queue.length t.queue = 1
    in
    if was_empty then Condition.signal t.not_empty

  let pop t =
    let elem, was_full =
      Mutex.protect t.mutex @@ fun () -&gt;
      while Queue.length t.queue = 0 do
        Condition.wait t.not_empty t.mutex
      done;
      let was_full = Queue.length t.queue = t.capacity in
      Queue.pop t.queue, was_full
    in
    if was_full then Condition.signal t.not_full;
    elem
end</code></pre><p>The above is definitely not the fastest nor the most scalable bounded queue, but we can now demonstrate it with the cooperative <a href="../Picos_fifos/index.html"><code>Picos_fifos</code></a> scheduler:</p><pre class="language-ocaml"><code># Picos_fifos.run ~forbid:false @@ fun () -&gt;

  let bq = Bounded_queue.create ~capacity:3 () in

  Bundle.join_after begin fun bundle -&gt;
    Bundle.fork bundle begin fun () -&gt;
      while true do
        Printf.printf &quot;Popped %d\n%!&quot; (Bounded_queue.pop bq)
      done
    end;

    for i=1 to 5 do
      Printf.printf &quot;Pushing %d\n%!&quot; i;
      Bounded_queue.push bq i
    done;

    Printf.printf &quot;All done?\n%!&quot;;

    Control.yield ();

    Bundle.terminate bundle
  end;

  Printf.printf &quot;Pushing %d\n%!&quot; 101;
  Bounded_queue.push bq 101;

  Printf.printf &quot;Popped %d\n%!&quot; (Bounded_queue.pop bq)
Pushing 1
Pushing 2
Pushing 3
Pushing 4
Popped 1
Popped 2
Popped 3
Pushing 5
All done?
Popped 4
Popped 5
Pushing 101
Popped 101
- : unit = ()</code></pre><p>Notice how the producer was able to push three elements to the queue after which the fourth push blocked and the consumer was started. Also, after canceling the consumer, the queue could still be used just fine.</p></div></body></html>
