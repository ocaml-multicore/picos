<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Picos_structured (picos.Picos_structured)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">picos</a> &#x00BB; Picos_structured</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Picos_structured</span></code></h1><p>Basic structured concurrency primitives for <a href="../Picos/index.html"><code>Picos</code></a>.</p><p>This library essentially provides one user level interface for structuring fibers with any Picos compatible scheduler. This library is both meant to serve as an example of what can be done and to also provide practical means for programming with fibers. Hopefully there will be many more libraries implemented in Picos like this providing different approaches, patterns, and idioms for structuring concurrent programs.</p></header><nav class="odoc-toc"><ul><li><a href="#modules">Modules</a></li><li><a href="#examples">Examples</a><ul><li><a href="#understanding-cancelation">Understanding cancelation</a></li><li><a href="#a-simple-echo-server-and-clients">A simple echo server and clients</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="modules"><a href="#modules" class="anchor"></a>Modules</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Finally"><a href="#module-Finally" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Finally/index.html">Finally</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Syntax for avoiding resource leaks.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Control"><a href="#module-Control" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Control/index.html">Control</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Basic control operations and exceptions for structured concurrency.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Promise"><a href="#module-Promise" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Promise/index.html">Promise</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A cancelable promise.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Bundle"><a href="#module-Bundle" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Bundle/index.html">Bundle</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A dynamic bundle of fibers guaranteed to be joined at the end.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Run"><a href="#module-Run" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Run/index.html">Run</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Operations for running fibers in specific patterns.</p></div></div><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p>First we open some modules for convenience:</p><pre class="language-ocaml"><code>open Picos_structured.Finally
open Picos_structured
open Picos_stdio
open Picos_sync</code></pre><h3 id="understanding-cancelation"><a href="#understanding-cancelation" class="anchor"></a>Understanding cancelation</h3><p>Consider the following program:</p><pre class="language-ocaml"><code>let main () =
  Bundle.join_after begin fun bundle -&gt;
    let promise =
      Bundle.fork_as_promise bundle
      @@ fun () -&gt; Control.block ()
    in

    Bundle.fork bundle begin fun () -&gt;
      Promise.await promise
    end;

    Bundle.fork bundle begin fun () -&gt;
      let mutex = Mutex.create () in
      let condition = Condition.create () in
      Mutex.protect mutex begin fun () -&gt;
        while true do
          Condition.wait condition mutex
        done
      end
    end;

    Bundle.fork bundle begin fun () -&gt;
      let@ inn, out =
        finally Unix.close_pair @@ fun () -&gt;
        Unix.socketpair ~cloexec:true
          PF_UNIX SOCK_STREAM 0
      in
      Unix.set_nonblock inn;
      let n =
        Unix.read inn (Bytes.create 1) 0 1
      in
      assert (n = 1)
    end;

    Bundle.fork bundle begin fun () -&gt;
      let a_month =
        60.0 *. 60.0 *. 24.0 *. 30.0
      in
      Control.sleep ~seconds:a_month
    end;

    (* Let the children get stuck *)
    Control.yield ();

    Bundle.terminate bundle
  end</code></pre><p>First of all, note that above the <a href="../Picos_sync/Mutex/index.html" title="Picos_sync.Mutex"><code>Mutex</code></a> and <a href="../Picos_sync/Condition/index.html" title="Picos_sync.Condition"><code>Condition</code></a> modules come from the <a href="../Picos_sync/index.html"><code>Picos_sync</code></a> library and the <a href="../Picos_stdio/Unix/index.html" title="Picos_stdio.Unix"><code>Unix</code></a> module comes from the <a href="../Picos_stdio/index.html"><code>Picos_stdio</code></a> library. They do not come from the standard OCaml libraries.</p><p>The above program creates a <a href="Bundle/index.html" title="Bundle">bundle</a> of fibers and <a href="Bundle/index.html#val-fork" title="Bundle.fork">forks</a> several fibers to the bundle that all block in various ways. In detail,</p><ul><li><a href="Control/index.html#val-block"><code>Control.block</code></a> never returns,</li><li><a href="Promise/index.html#val-await"><code>Promise.await</code></a> never returns as the <code>promise</code> won't be completed,</li><li><a href="../Picos_sync/Condition/index.html#val-wait" title="Picos_sync.Condition.wait"><code>Condition.wait</code></a> never returns, because the condition is never signaled,</li><li><a href="../Picos_stdio/Unix/index.html#val-read" title="Picos_stdio.Unix.read"><code>Unix.read</code></a> never returns, because the socket is never written to, and the</li><li><a href="Control/index.html#val-sleep"><code>Control.sleep</code></a> call would return only after about a month.</li></ul><p>Fibers forked to a bundle can be canceled in various ways. In the above program we call <a href="Bundle/index.html#val-terminate"><code>Bundle.terminate</code></a> to cancel all the fibers and effectively close the bundle. This allows the program to return normally immediately and without leaking or leaving anything in an invalid state:</p><pre class="language-ocaml"><code># Picos_fifos.run main
- : unit = ()</code></pre><p>Now, the point of the above example isn't that you should just call <a href="Bundle/index.html#val-terminate" title="Bundle.terminate"><code>terminate</code></a> when your program gets stuck. ðŸ˜…</p><p>What the above example hopefully demonstrates is that concurrent abstractions like mutexes and condition variables, asynchronous IO libraries, and others can be designed to support cancelation.</p><p>Cancelation is a control flow mechanism that allows structured concurrent abstractions, like the <a href="Bundle/index.html"><code>Bundle</code></a> abstraction, to (hopefully) gracefully tear down concurrent fibers in case of errors. Indeed, one of the basic ideas behind the <a href="Bundle/index.html"><code>Bundle</code></a> abstraction is that in case any fiber forked to the bundle raises an unhandled exception, the whole bundle will be terminated and the error will raised from the bundle, which allows you to understand what went wrong, instead of having to debug a program that mysteriously gets stuck, for example.</p><p>Cancelation can also, with some care, be used as a mechanism to terminate fibers once they are no longer needed. However, just like sleep, for example, cancelation is inherently prone to races, i.e. it is difficult to understand the exact point and state at which a fiber gets canceled and it is usually non-deterministic, and therefore cancelation is not recommended for use as a general synchronization or communication mechanism.</p><h3 id="a-simple-echo-server-and-clients"><a href="#a-simple-echo-server-and-clients" class="anchor"></a>A simple echo server and clients</h3><p>Let's build a simple TCP echo server and run it with some clients.</p><p>We first define a function for the server:</p><pre class="language-ocaml"><code>let run_server socket =
  Unix.listen socket 8;

  Bundle.join_after begin fun bundle -&gt;
    while true do
      let^ client =
        finally Unix.close @@ fun () -&gt;
        Unix.accept
          ~cloexec:true socket |&gt; fst
      in

      (* Fork a fiber for client *)
      Bundle.fork bundle begin fun () -&gt;
        let@ client = move client in
        Unix.set_nonblock client;

        let bytes =
          Bytes.create 100
        in
        let n =
          Unix.read client bytes 0
            (Bytes.length bytes)
        in
        Unix.write client bytes 0 n
        |&gt; ignore
      end
    done
  end</code></pre><p>The server function expects a bound socket and starts listening. For each accepted client the server forks a new fiber to handle it. The client socket is <a href="Finally/index.html#val-move" title="Finally.move">moved</a> from the server fiber to the client fiber to avoid leaks and to ensure that the socket will be closed.</p><p>Let's then define a function for the clients:</p><pre class="language-ocaml"><code>let run_client addr =
  let@ socket =
    finally Unix.close @@ fun () -&gt;
    Unix.socket ~cloexec:true
      PF_INET SOCK_STREAM 0
  in
  Unix.set_nonblock socket;
  Unix.connect socket addr;

  let msg = &quot;Hello!&quot; in
  Unix.write_substring
    socket msg 0 (String.length msg)
  |&gt; ignore;

  let bytes =
    Bytes.create (String.length msg)
  in
  let n =
    Unix.read socket bytes 0
      (Bytes.length bytes)
  in

  Printf.printf &quot;Received: %s\n%!&quot;
    (Bytes.sub_string bytes 0 n)</code></pre><p>The client function takes the address of the server and connects a socket to the server address. It then writes a message to the server and reads a reply from the server and prints it.</p><p>Here is the main program:</p><pre class="language-ocaml"><code>let main () =
  let@ socket =
    finally Unix.close @@ fun () -&gt;
    Unix.socket ~cloexec:true
      PF_INET SOCK_STREAM 0
  in
  Unix.set_nonblock socket;

  (* Let system determine the port *)
  Unix.bind socket Unix.(
    ADDR_INET(inet_addr_loopback, 0));

  let addr =
    Unix.getsockname socket
  in

  Bundle.join_after begin fun bundle -&gt;
    (* Start server *)
    let server =
      Bundle.fork_as_promise bundle
      @@ fun () -&gt; run_server socket
    in

    (* Run clients concurrently *)
    Bundle.join_after begin fun bundle -&gt;
      for _ = 1 to 5 do
        Bundle.fork bundle (fun () -&gt;
          run_client addr)
      done
    end;

    (* Stop server *)
    Promise.terminate server
  end</code></pre><p>The main program creates a socket for the server and binds it. The server is then started as a new fiber. Then the clients are started to run concurrently. Finally the server is terminated.</p><p>Finally we run the main program with a scheduler:</p><pre class="language-ocaml"><code># Picos_fifos.run main
Received: Hello!
Received: Hello!
Received: Hello!
Received: Hello!
Received: Hello!
- : unit = ()</code></pre><p>As an exercise, you might want to refactor the server to avoid <a href="Finally/index.html#val-move" title="Finally.move">moving</a> the file descriptors and use a <a href="Finally/index.html#val-let@" title="Finally.let@">recursive</a> accept loop instead. You could also <a href="Bundle/index.html#val-terminate" title="Bundle.terminate">terminate the whole bundle</a> at the end instead of just terminating the server.</p></div></body></html>
