<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Picos (picos.Picos)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">picos</a> &#x00BB; Picos</nav><header class="odoc-preamble"><h1>Module <code><span>Picos</span></code></h1><p>A <a href="https://en.wikipedia.org/wiki/Systems_programming">systems programming</a> interface between effects based schedulers and concurrent abstractions.</p><p>This is essentially an interface between schedulers and concurrent abstractions that need to communicate with a scheduler. Perhaps an enlightening analogy is to say that this is the <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> of effects based schedulers.</p><p>ℹ️ Picos, i.e. <i>this module</i>, is not intended to be an application level concurrent programming library or framework. If you are looking for a library or framework for programming concurrent applications, then this module is probably not what you are looking for.</p></header><nav class="odoc-toc"><ul><li><a href="#the-architecture-of-picos">The architecture of Picos</a></li><li><a href="#understanding-cancelation">Understanding cancelation</a><ul><li><a href="#cancelation-in-picos">Cancelation in Picos</a></li></ul></li><li><a href="#modules-reference">Modules reference</a><ul><li><a href="#core-modules">Core modules</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="the-architecture-of-picos"><a href="#the-architecture-of-picos" class="anchor"></a>The architecture of Picos</h2><p>The core concepts of Picos are</p><ul><li><a href="Trigger/index.html"><code>Trigger</code></a> — ability to await for a signal,</li><li><a href="Computation/index.html"><code>Computation</code></a> — a cancelable computation, and</li><li><a href="Fiber/index.html"><code>Fiber</code></a> — an independent thread of execution,</li></ul><p>that are implemented in terms of the effects</p><ul><li><a href="Trigger/index.html#extension-Await"><code>Trigger.Await</code></a> — to suspend and resume a fiber,</li><li><a href="Computation/index.html#extension-Cancel_after"><code>Computation.Cancel_after</code></a> — to cancel a computation after given period of time,</li><li><a href="Fiber/index.html#extension-Current"><code>Fiber.Current</code></a> — to obtain the unique handle of the current fiber,</li><li><a href="Fiber/index.html#extension-Yield"><code>Fiber.Yield</code></a> — to cooperatively request rescheduling the current fiber, and</li><li><a href="Fiber/index.html#extension-Spawn"><code>Fiber.Spawn</code></a> — to start new fibers,</li></ul><p>that can be used to implement many kinds of higher level concurrent programming facilities.</p><h2 id="understanding-cancelation"><a href="#understanding-cancelation" class="anchor"></a>Understanding cancelation</h2><p>A central idea of Picos is to provide a collection of building blocks for parallelism safe cancelation.</p><p>Consider the following motivating example:</p><pre class="language-ocaml"><code>Mutex.protect mutex begin fun () -&gt;
  while true do
    Condition.wait condition mutex
  done
end</code></pre><p>Assume that the fiber executing the above computation might be canceled, at any point, by another fiber running in parallel. How could that be done ensuring both safety and liveness?</p><ul><li>For safety, cancelation should not leave the program in an invalid state or cause the program to leak memory. In this case, the ownership of the mutex must be transferred to the next fiber or be left unlocked and no references to unused objects must be left in the mutex or the condition variable.</li></ul><ul><li>For liveness, cancelation should take effect as soon as possible. In this case, cancelation should take effect even during the <span class="xref-unresolved" title="Picos_std_sync.Mutex.lock"><code>Mutex.lock</code></span> inside <span class="xref-unresolved" title="Picos_std_sync.Mutex.protect"><code>Mutex.protect</code></span> and the <span class="xref-unresolved" title="Picos_std_sync.Condition.wait"><code>Condition.wait</code></span> operations when the fiber might be in a suspended state awaiting for a signal to continue.</li></ul><p>Here is another motivating example:</p><pre class="language-ocaml"><code>(* ... allocate resources ... *)
Fun.protect ~finally begin fun () -&gt;
  Flock.join_after begin fun () -&gt;
    (* ... *)
    Flock.fork begin fun () -&gt;
      (* ... may use resources ... *)
    end;
    (* ... *)
  end;
  (* ... resources no longer used ... *)
end</code></pre><p>The idea is that the main or parent fiber allocates some resources, which are then used by child fibers running in parallel. What should happen when the main fiber gets canceled? We again have both safety and liveness concerns:</p><ul><li>For safety, to ensure that resources are not finalized prematurely, the <span class="xref-unresolved" title="Picos_std_structured.Flock.join_after"><code>Flock.join_after</code></span> call must not return or raise before all of the child fibers have terminated.</li></ul><ul><li>For liveness, when the parent fiber gets canceled, we'd like all the child fibers to also get canceled.</li></ul><p>Picos is designed to allow the above motivating examples and more to be implemented correctly addressing both safety and liveness.</p><h3 id="cancelation-in-picos"><a href="#cancelation-in-picos" class="anchor"></a>Cancelation in Picos</h3><p>The <a href="Fiber/index.html"><code>Fiber</code></a> concept in Picos corresponds to an independent thread of execution. A fiber may explicitly <a href="Fiber/index.html#val-forbid" title="Fiber.forbid">forbid</a> or <a href="Fiber/index.html#val-permit" title="Fiber.permit">permit</a> the scheduler from propagating cancelation to it. This is important for the implementation of some key concurrent abstractions such as condition variables, where it is necessary to forbid cancelation when the associated mutex is reacquired.</p><p>Each fiber has an associated <a href="Computation/index.html"><code>Computation</code></a> at all times. A computation is something that needs to be completed either by <a href="Computation/index.html#val-return" title="Computation.return">returning</a> a value through it or by <a href="Computation/index.html#val-cancel" title="Computation.cancel">canceling</a> it with an exception. To cancel a fiber one cancels the computation associated with the fiber or any computation whose <a href="Computation/index.html#val-canceler" title="Computation.canceler">cancelation is propagated</a> to the computation associated with the fiber.</p><p>Before a computation has been completed, it is also possible to <a href="Computation/index.html#val-try_attach" title="Computation.try_attach">attach</a> a <a href="Trigger/index.html"><code>Trigger</code></a> to the computation and also to later <a href="Computation/index.html#val-detach" title="Computation.detach">detach</a> the trigger from the computation. A trigger attached to a computation is <a href="Trigger/index.html#val-signal" title="Trigger.signal">signaled</a> as the computation is completed.</p><p>The <a href="Trigger/index.html"><code>Trigger</code></a> concept in Picos is what allows a fiber to be suspended and later resumed. A fiber can create a trigger, add it to any shared data structure(s), and <a href="Trigger/index.html#val-await" title="Trigger.await">await</a> for the trigger to be signaled. The await operation, which is <a href="Trigger/index.html#extension-Await" title="Trigger.Await">implemented by the scheduler</a>, also, in case the fiber permits cancelation, attaches the trigger to the computation of the fiber when it suspends the fiber. This is what allows a fiber to be resumed via cancelation of the computation.</p><p>The return value of <a href="Trigger/index.html#val-await" title="Trigger.await">await</a> tells whether the fiber was resumed normally or due to being canceled and the caller then needs to properly handle either case. After being canceled, depending on the concurrent abstraction being implemented, the caller might need to e.g. remove references to the trigger from the shared data structures, cancel asynchronous IO operations, or transfer ownership of a mutex to the next fiber in the queue of the mutex.</p><h2 id="modules-reference"><a href="#modules-reference" class="anchor"></a>Modules reference</h2><p>For the examples in this document, we first open the <a href="#"><code>Picos</code></a> module</p><pre class="language-ocaml"><code>open Picos</code></pre><p>as well as the <code>Picos_std_structured</code> library,</p><pre class="language-ocaml"><code>open Picos_std_structured</code></pre><p>which we will be using for managing fibers in some of the examples, and define a simple scheduler on OCaml 4</p><pre class="language-ocaml"><code>let run main = Picos_mux_thread.run main</code></pre><p>using <span class="xref-unresolved" title="Picos_mux_thread">the basic thread based scheduler</span> and on OCaml 5</p><pre class="language-ocaml"><code>let run main = Picos_mux_random.run_on ~n_domains:2 main</code></pre><p>using <span class="xref-unresolved" title="Picos_mux_random">the randomized effects based scheduler</span> that come with Picos as samples.</p><h3 id="core-modules"><a href="#core-modules" class="anchor"></a>Core modules</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Trigger"><a href="#module-Trigger" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Trigger/index.html">Trigger</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Ability to await for a signal.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Computation"><a href="#module-Computation" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Computation/index.html">Computation</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A cancelable computation.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Fiber"><a href="#module-Fiber" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Fiber/index.html">Fiber</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An independent thread of execution.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Handler"><a href="#module-Handler" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Handler/index.html">Handler</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Handler for the effects based operations of Picos for OCaml 4.</p></div></div></div></body></html>
