<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Picos (picos.Picos)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../index.html">picos</a> &#x00BB; Picos</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Picos</span></code></h1><p>Framework for interoperable effects based concurrency.</p><p>This is essentially an interface between schedulers and other elements that need to communicate with a scheduler. Perhaps an enlightening analogy is to say that this is the <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> of effects based schedulers.</p><p>‚ÑπÔ∏è Picos, i.e. this module, is not intended to be an application level concurrent programming library or framework. If you are looking for a library or framework for programming concurrent applications, then this module is probably not what you are looking for.</p></header><nav class="odoc-toc"><ul><li><a href="#the-architecture-of-picos">The architecture of Picos</a></li><li><a href="#understanding-cancelation">Understanding cancelation</a><ul><li><a href="#cancelation-in-picos">Cancelation in Picos</a></li></ul></li><li><a href="#modules-reference">Modules reference</a><ul><li><a href="#auxiliary-modules">Auxiliary modules</a></li><li><a href="#core-modules">Core modules</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="the-architecture-of-picos"><a href="#the-architecture-of-picos" class="anchor"></a>The architecture of Picos</h2><p>The core concepts of Picos are</p><ul><li><a href="Trigger/index.html"><code>Trigger</code></a> ‚Äî ability to await for a signal,</li><li><a href="Computation/index.html"><code>Computation</code></a> ‚Äî a cancelable computation, and</li><li><a href="Fiber/index.html"><code>Fiber</code></a> ‚Äî an independent thread of execution,</li></ul><p>that are implemented in terms of the effects</p><ul><li><a href="Trigger/index.html#extension-Await"><code>Trigger.Await</code></a> ‚Äî to suspend and resume a fiber,</li><li><a href="Computation/index.html#extension-Cancel_after"><code>Computation.Cancel_after</code></a> ‚Äî to cancel a computation after given period of time,</li><li><a href="Fiber/index.html#extension-Current"><code>Fiber.Current</code></a> ‚Äî to obtain the unique handle of the current fiber,</li><li><a href="Fiber/index.html#extension-Yield"><code>Fiber.Yield</code></a> ‚Äî to cooperatively request rescheduling the current fiber, and</li><li><a href="Fiber/index.html#extension-Spawn"><code>Fiber.Spawn</code></a> ‚Äî to start new fibers,</li></ul><p>that can be used to implement many kinds of higher level concurrent programming facilities.</p><h2 id="understanding-cancelation"><a href="#understanding-cancelation" class="anchor"></a>Understanding cancelation</h2><p>A central idea of Picos is to provide a collection of building blocks for parallelism safe cancelation. Consider the following characteristic example:</p><pre class="language-ocaml"><code>Mutex.protect mutex begin fun () -&gt;
  while true do
    Condition.wait condition mutex
  done
end</code></pre><p>Assume that the fiber executing the above computation might be canceled, at any point, by another fiber running in parallel. How could that be done both effectively and safely?</p><ul><li>To be effective, cancelation should take effect as soon as possible. In this case, cancelation should take effect even during the <a href="../Picos_sync/Mutex/index.html#val-lock" title="Picos_sync.Mutex.lock"><code>Mutex.lock</code></a> inside <a href="../Picos_sync/Mutex/index.html#val-protect" title="Picos_sync.Mutex.protect"><code>Mutex.protect</code></a> and the <a href="../Picos_sync/Condition/index.html#val-wait" title="Picos_sync.Condition.wait"><code>Condition.wait</code></a> operations when the fiber might be in a suspended state awaiting for a signal to continue.</li><li>To be safe, cancelation should not leave the program in an invalid state or cause the program to leak memory. In this case, the ownership of the mutex must be transferred to the next fiber or be left unlocked and no references to unused objects must be left in the mutex or the condition variable.</li></ul><p>Picos allows <a href="../Picos_sync/Mutex/index.html" title="Picos_sync.Mutex"><code>Mutex</code></a> and <a href="../Picos_sync/Condition/index.html" title="Picos_sync.Condition"><code>Condition</code></a> to be implemented such that cancelation may safely take effect at or during calls to <a href="../Picos_sync/Mutex/index.html#val-lock" title="Picos_sync.Mutex.lock"><code>Mutex.lock</code></a> and <a href="../Picos_sync/Condition/index.html#val-wait" title="Picos_sync.Condition.wait"><code>Condition.wait</code></a>.</p><h3 id="cancelation-in-picos"><a href="#cancelation-in-picos" class="anchor"></a>Cancelation in Picos</h3><p>The <a href="Fiber/index.html"><code>Fiber</code></a> concept in Picos corresponds to an independent thread of execution. A fiber may explicitly <a href="Fiber/index.html#val-forbid" title="Fiber.forbid">forbid</a> or <a href="Fiber/index.html#val-permit" title="Fiber.permit">permit</a> the scheduler from propagating cancelation to it. This is important for the implementation of some key concurrent abstractions such as condition variables, where it is necessary to forbid cancelation when the associated mutex is reacquired.</p><p>Each fiber has an associated <a href="Computation/index.html"><code>Computation</code></a>. A computation is something that needs to be completed either by <a href="Computation/index.html#val-return" title="Computation.return">returning</a> a value through it or by <a href="Computation/index.html#val-cancel" title="Computation.cancel">canceling</a> it with an exception. To cancel a fiber one cancels the <a href="Fiber/index.html#val-computation" title="Fiber.computation">computation</a> associated with the fiber.</p><p>Before a computation has been completed, it is also possible to <a href="Computation/index.html#val-try_attach" title="Computation.try_attach">attach</a> a <a href="Trigger/index.html"><code>Trigger</code></a> to the computation and also to later <a href="Computation/index.html#val-detach" title="Computation.detach">detach</a> the trigger from the computation. A trigger attached to a computation is <a href="Trigger/index.html#val-signal" title="Trigger.signal">signaled</a> as the computation is completed.</p><p>The <a href="Trigger/index.html"><code>Trigger</code></a> concept in Picos is what allows a fiber to be suspended and later resumed. A fiber can create a trigger, add it to any shared data structure(s), and <a href="Trigger/index.html#val-await" title="Trigger.await">await</a> for the trigger to be signaled. The await operation, which is <a href="Trigger/index.html#extension-Await" title="Trigger.Await">implemented by the scheduler</a>, also, in case the fiber permits cancelation, attaches the trigger to the computation of the fiber when it suspends the fiber. This is what allows a fiber to be resumed via cancelation of the computation.</p><p>The return value of <a href="Trigger/index.html#val-await" title="Trigger.await">await</a> tells whether the fiber was resumed normally or due to being canceled and the caller then needs to properly handle either case. After being canceled, depending on the concurrent abstraction being implemented, the caller might need to e.g. remove references to the trigger from the shared data structures, cancel asynchronous IO operations, or transfer ownership of a mutex to the next fiber in the queue of the mutex.</p><h2 id="modules-reference"><a href="#modules-reference" class="anchor"></a>Modules reference</h2><p>For the examples in this document, we first open the <a href="#"><code>Picos</code></a> module</p><pre class="language-ocaml"><code>open Picos</code></pre><p>as well as a simple helper for cleaning up resources</p><pre class="language-ocaml"><code>open Foundation.Finally</code></pre><p>and define a simple scheduler on OCaml 4</p><pre class="language-ocaml"><code>let run main =
  Picos_threaded.run ~forbid:false main</code></pre><p>using <a href="../Picos_threaded/index.html" title="Picos_threaded">the basic thread based scheduler</a> and on OCaml 5</p><pre class="language-ocaml"><code>let run main =
  Picos_fifos.run ~forbid:false main</code></pre><p>using <a href="../Picos_fifos/index.html" title="Picos_fifos">the basic effects based scheduler</a> that come with Picos as samples.</p><h3 id="auxiliary-modules"><a href="#auxiliary-modules" class="anchor"></a>Auxiliary modules</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Exn_bt"><a href="#module-Exn_bt" class="anchor"></a><code><span><span class="keyword">module</span> Exn_bt</span><span> = <a href="../Picos_exn_bt/index.html">Picos_exn_bt</a></span></code></div><div class="spec-doc"><p>Exceptions with backtraces.</p></div></div><h3 id="core-modules"><a href="#core-modules" class="anchor"></a>Core modules</h3><p>Please note that the example code snippets in this documentation may e.g. use the <code>Domain</code> and <code>Unix</code> modules in order to be able to describe Picos concepts in isolation in the absence of a Picos compatible scheduler.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Trigger"><a href="#module-Trigger" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Trigger/index.html">Trigger</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Ability to await for a signal.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Computation"><a href="#module-Computation" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Computation/index.html">Computation</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A cancelable computation.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Fiber"><a href="#module-Fiber" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Fiber/index.html">Fiber</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An independent thread of execution.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Handler"><a href="#module-Handler" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Handler/index.html">Handler</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Handler for the effects based operations of Picos for OCaml 4.</p></div></div></div></body></html>
